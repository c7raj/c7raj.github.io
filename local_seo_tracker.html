<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Local SEO Grid Tracker</title>

    <!-- Leaflet CSS for Maps -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

    <!-- Chart.js for Charts -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #fff;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 30px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            margin-bottom: 30px;
        }

        header h1 {
            font-size: 2.5rem;
            background: linear-gradient(90deg, #00d4ff, #7b2cbf);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        header p {
            color: #888;
            margin-top: 10px;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 30px;
        }

        @media (max-width: 1024px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }

        .sidebar {
            background: rgba(255,255,255,0.05);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .sidebar h2 {
            font-size: 1.2rem;
            margin-bottom: 20px;
            color: #00d4ff;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-size: 0.9rem;
            color: #aaa;
        }

        .form-group input, .form-group select, .form-group textarea {
            width: 100%;
            padding: 12px 15px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            background: rgba(255,255,255,0.05);
            color: #fff;
            font-size: 0.95rem;
            transition: border-color 0.3s;
        }

        .form-group input:focus, .form-group select:focus, .form-group textarea:focus {
            outline: none;
            border-color: #00d4ff;
        }

        .form-group textarea {
            min-height: 100px;
            resize: vertical;
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .btn {
            width: 100%;
            padding: 15px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 10px;
        }

        .btn-primary {
            background: linear-gradient(90deg, #00d4ff, #7b2cbf);
            color: #fff;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0,212,255,0.4);
        }

        .btn-secondary {
            background: rgba(255,255,255,0.1);
            color: #fff;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .btn-secondary:hover {
            background: rgba(255,255,255,0.2);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .main-content {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .card {
            background: rgba(255,255,255,0.05);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .card h3 {
            font-size: 1.1rem;
            margin-bottom: 20px;
            color: #00d4ff;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .metric-card {
            background: rgba(255,255,255,0.05);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .metric-value {
            font-size: 2rem;
            font-weight: 700;
            background: linear-gradient(90deg, #00d4ff, #7b2cbf);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .metric-label {
            font-size: 0.85rem;
            color: #888;
            margin-top: 5px;
        }

        #map {
            height: 400px;
            border-radius: 10px;
            z-index: 1;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .tab-btn {
            padding: 10px 20px;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
        }

        .tab-btn.active {
            background: linear-gradient(90deg, #00d4ff, #7b2cbf);
            border-color: transparent;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .grid-visual {
            display: grid;
            gap: 5px;
            margin: 20px 0;
        }

        .grid-cell {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 5px;
            font-weight: 600;
            font-size: 0.85rem;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .grid-cell:hover {
            transform: scale(1.1);
            z-index: 10;
        }

        .grid-cell.rank-1-3 { background: #4CAF50; color: white; }
        .grid-cell.rank-4-10 { background: #FFC107; color: black; }
        .grid-cell.rank-11-20 { background: #FF9800; color: white; }
        .grid-cell.rank-not-found { background: #F44336; color: white; }
        .grid-cell.no-data { background: #424242; color: #888; }

        .legend {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            margin-top: 15px;
            font-size: 0.85rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }

        .progress-container {
            margin: 20px 0;
        }

        .progress-bar {
            height: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00d4ff, #7b2cbf);
            width: 0%;
            transition: width 0.3s;
        }

        .progress-text {
            font-size: 0.85rem;
            color: #888;
            margin-top: 8px;
        }

        .status-message {
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-size: 0.9rem;
        }

        .status-info { background: rgba(0,212,255,0.1); border: 1px solid #00d4ff; }
        .status-success { background: rgba(76,175,80,0.1); border: 1px solid #4CAF50; }
        .status-error { background: rgba(244,67,54,0.1); border: 1px solid #F44336; }
        .status-warning { background: rgba(255,193,7,0.1); border: 1px solid #FFC107; color: #FFC107; }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }

        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        th {
            background: rgba(255,255,255,0.05);
            font-weight: 600;
            color: #00d4ff;
        }

        tr:hover {
            background: rgba(255,255,255,0.02);
        }

        .chart-container {
            position: relative;
            height: 300px;
        }

        .hidden {
            display: none !important;
        }

        .api-note {
            background: rgba(255,193,7,0.1);
            border: 1px solid #FFC107;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-size: 0.85rem;
            color: #FFC107;
        }

        .api-note a {
            color: #00d4ff;
        }

        .keyword-tag {
            display: inline-block;
            padding: 5px 12px;
            background: rgba(0,212,255,0.2);
            border-radius: 20px;
            margin: 3px;
            font-size: 0.85rem;
        }

        .export-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .export-buttons .btn {
            width: auto;
            padding: 10px 20px;
        }

        /* Scrollable table container */
        .table-container {
            max-height: 400px;
            overflow-y: auto;
        }

        /* Loading spinner */
        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: #00d4ff;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Local SEO Grid Tracker</h1>
            <p>Track your local search visibility across geographic grid points</p>
        </header>

        <div class="main-grid">
            <!-- Sidebar - Configuration -->
            <aside class="sidebar">
                <h2>Configuration</h2>

                <div class="api-note">
                    <strong>Note:</strong> This tool uses <a href="https://serpapi.com" target="_blank">SerpAPI</a> for search results.
                    Get your free API key (100 searches/month) at serpapi.com
                </div>

                <div class="form-group">
                    <label>SerpAPI Key</label>
                    <input type="password" id="apiKey" placeholder="Enter your SerpAPI key">
                </div>

                <div class="form-group">
                    <label>Business Name</label>
                    <input type="text" id="businessName" placeholder="e.g., Joe's Plumbing Service">
                </div>

                <div class="form-group">
                    <label>Business Address</label>
                    <input type="text" id="businessAddress" placeholder="e.g., 123 Main St, New York, NY">
                    <button class="btn btn-secondary" style="margin-top: 10px;" onclick="geocodeAddress()">
                        Lookup Coordinates
                    </button>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label>Latitude</label>
                        <input type="number" id="centerLat" step="0.000001" placeholder="40.7128">
                    </div>
                    <div class="form-group">
                        <label>Longitude</label>
                        <input type="number" id="centerLon" step="0.000001" placeholder="-74.0060">
                    </div>
                </div>

                <div class="form-group">
                    <label>Keywords (one per line)</label>
                    <textarea id="keywords" placeholder="plumber&#10;emergency plumber&#10;drain cleaning&#10;water heater repair"></textarea>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label>Grid Size</label>
                        <select id="gridSize">
                            <option value="3">3 × 3 (9 points)</option>
                            <option value="4">4 × 4 (16 points)</option>
                            <option value="5">5 × 5 (25 points)</option>
                            <option value="6" selected>6 × 6 (36 points)</option>
                            <option value="7">7 × 7 (49 points)</option>
                            <option value="8">8 × 8 (64 points)</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Radius (km)</label>
                        <select id="areaRadius">
                            <option value="0.5">0.5 km</option>
                            <option value="1" selected>1 km</option>
                            <option value="1.5">1.5 km</option>
                            <option value="2">2 km</option>
                            <option value="3">3 km</option>
                            <option value="5">5 km</option>
                        </select>
                    </div>
                </div>

                <div class="form-group">
                    <label>Country</label>
                    <select id="country">
                        <option value="us">United States</option>
                        <option value="uk">United Kingdom</option>
                        <option value="ca">Canada</option>
                        <option value="au">Australia</option>
                        <option value="in">India</option>
                        <option value="de">Germany</option>
                        <option value="fr">France</option>
                    </select>
                </div>

                <button class="btn btn-secondary" onclick="generateGrid()">
                    Generate Grid Preview
                </button>

                <button class="btn btn-primary" id="startTrackingBtn" onclick="startTracking()">
                    Start Tracking
                </button>

                <button class="btn btn-secondary" id="stopTrackingBtn" onclick="stopTracking()" style="display: none; background: #F44336;">
                    Stop Tracking
                </button>
            </aside>

            <!-- Main Content -->
            <main class="main-content">
                <!-- Metrics Cards -->
                <div class="metrics-grid" id="metricsSection" style="display: none;">
                    <div class="metric-card">
                        <div class="metric-value" id="metricLocalPack">0%</div>
                        <div class="metric-label">Local Pack Visibility</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="metricTop3">0%</div>
                        <div class="metric-label">Top 3 Visibility</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="metricOrganic">0%</div>
                        <div class="metric-label">Organic Visibility</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="metricAvgPos">-</div>
                        <div class="metric-label">Avg Local Position</div>
                    </div>
                </div>

                <!-- Progress Section -->
                <div class="card" id="progressSection" style="display: none;">
                    <h3>Tracking Progress</h3>
                    <div class="progress-container">
                        <div class="progress-bar">
                            <div class="progress-fill" id="progressFill"></div>
                        </div>
                        <div class="progress-text" id="progressText">Preparing...</div>
                    </div>
                    <div id="statusMessage"></div>
                </div>

                <!-- Tabs -->
                <div class="card">
                    <div class="tabs">
                        <button class="tab-btn active" onclick="showTab('map')">Map View</button>
                        <button class="tab-btn" onclick="showTab('grid')">Grid Matrix</button>
                        <button class="tab-btn" onclick="showTab('keywords')">Keyword Analysis</button>
                        <button class="tab-btn" onclick="showTab('data')">Raw Data</button>
                    </div>

                    <!-- Map Tab -->
                    <div class="tab-content active" id="tab-map">
                        <div id="map"></div>
                        <div class="legend">
                            <div class="legend-item">
                                <div class="legend-color" style="background: #4CAF50;"></div>
                                <span>Rank 1-3</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFC107;"></div>
                                <span>Rank 4-10</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FF9800;"></div>
                                <span>Rank 11-20</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #F44336;"></div>
                                <span>Not Found</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #424242;"></div>
                                <span>No Data</span>
                            </div>
                        </div>
                    </div>

                    <!-- Grid Matrix Tab -->
                    <div class="tab-content" id="tab-grid">
                        <h3>Position Grid Matrix</h3>
                        <p style="color: #888; margin-bottom: 15px;">Average local pack position at each grid point</p>
                        <div class="grid-visual" id="gridVisual"></div>
                        <div class="legend">
                            <div class="legend-item">
                                <div class="legend-color" style="background: #4CAF50;"></div>
                                <span>Rank 1-3</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFC107;"></div>
                                <span>Rank 4-10</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FF9800;"></div>
                                <span>Rank 11-20</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #F44336;"></div>
                                <span>Not Found</span>
                            </div>
                        </div>
                    </div>

                    <!-- Keywords Tab -->
                    <div class="tab-content" id="tab-keywords">
                        <h3>Keyword Performance</h3>
                        <div class="chart-container">
                            <canvas id="keywordChart"></canvas>
                        </div>
                        <div class="table-container" style="margin-top: 20px;">
                            <table id="keywordTable">
                                <thead>
                                    <tr>
                                        <th>Keyword</th>
                                        <th>Local Pack %</th>
                                        <th>Top 3 %</th>
                                        <th>Organic %</th>
                                        <th>Avg Position</th>
                                    </tr>
                                </thead>
                                <tbody></tbody>
                            </table>
                        </div>
                    </div>

                    <!-- Raw Data Tab -->
                    <div class="tab-content" id="tab-data">
                        <h3>Raw Tracking Data</h3>
                        <div class="export-buttons">
                            <button class="btn btn-secondary" onclick="exportCSV()">Export CSV</button>
                            <button class="btn btn-secondary" onclick="exportJSON()">Export JSON</button>
                        </div>
                        <div class="table-container" style="margin-top: 15px;">
                            <table id="rawDataTable">
                                <thead>
                                    <tr>
                                        <th>Point</th>
                                        <th>Keyword</th>
                                        <th>Local Pack</th>
                                        <th>Organic</th>
                                        <th>Competitors</th>
                                    </tr>
                                </thead>
                                <tbody></tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <script>
        // Global state
        let map = null;
        let gridPoints = [];
        let trackingResults = [];
        let isTracking = false;
        let keywordChart = null;
        let markers = [];

        // Initialize map
        function initMap() {
            map = L.map('map').setView([40.7128, -74.0060], 13);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors'
            }).addTo(map);
        }

        // Geocode address using Nominatim (free, no API key)
        async function geocodeAddress() {
            const address = document.getElementById('businessAddress').value;
            if (!address) {
                showStatus('Please enter an address', 'error');
                return;
            }

            showStatus('Looking up coordinates...', 'info');

            try {
                const response = await fetch(
                    `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}`,
                    {
                        headers: {
                            'User-Agent': 'LocalSEOTracker/1.0'
                        }
                    }
                );

                const data = await response.json();

                if (data && data.length > 0) {
                    const result = data[0];
                    document.getElementById('centerLat').value = parseFloat(result.lat).toFixed(6);
                    document.getElementById('centerLon').value = parseFloat(result.lon).toFixed(6);

                    // Update map view
                    map.setView([result.lat, result.lon], 14);

                    showStatus(`Found: ${result.display_name}`, 'success');
                } else {
                    showStatus('Address not found. Please try a different format.', 'error');
                }
            } catch (error) {
                showStatus('Error looking up address: ' + error.message, 'error');
            }
        }

        // Generate grid points
        function generateGridPoints(centerLat, centerLon, gridSize, radiusKm) {
            const points = [];

            // Convert km to degrees
            const latDegreePerKm = 1 / 111.0;
            const lonDegreePerKm = 1 / (111.0 * Math.cos(centerLat * Math.PI / 180));

            // Calculate spacing
            const latSpacing = (2 * radiusKm * latDegreePerKm) / (gridSize - 1);
            const lonSpacing = (2 * radiusKm * lonDegreePerKm) / (gridSize - 1);

            // Start points
            const startLat = centerLat - (radiusKm * latDegreePerKm);
            const startLon = centerLon - (radiusKm * lonDegreePerKm);

            // Generate grid
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const lat = startLat + (i * latSpacing);
                    const lon = startLon + (j * lonSpacing);

                    // Calculate distance from center
                    const distance = haversineDistance(centerLat, centerLon, lat, lon);

                    points.push({
                        id: `${i + 1}-${j + 1}`,
                        lat: parseFloat(lat.toFixed(6)),
                        lon: parseFloat(lon.toFixed(6)),
                        gridX: i + 1,
                        gridY: j + 1,
                        distanceKm: distance.toFixed(2)
                    });
                }
            }

            return points;
        }

        // Haversine distance calculation
        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Earth's radius in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // Generate and preview grid
        function generateGrid() {
            const centerLat = parseFloat(document.getElementById('centerLat').value);
            const centerLon = parseFloat(document.getElementById('centerLon').value);
            const gridSize = parseInt(document.getElementById('gridSize').value);
            const radiusKm = parseFloat(document.getElementById('areaRadius').value);

            if (isNaN(centerLat) || isNaN(centerLon)) {
                showStatus('Please enter valid coordinates or lookup an address', 'error');
                return;
            }

            gridPoints = generateGridPoints(centerLat, centerLon, gridSize, radiusKm);

            // Clear existing markers
            markers.forEach(m => map.removeLayer(m));
            markers = [];

            // Add business marker
            const businessMarker = L.marker([centerLat, centerLon], {
                icon: L.divIcon({
                    className: 'custom-marker',
                    html: '<div style="background: #F44336; width: 20px; height: 20px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.3);"></div>',
                    iconSize: [20, 20],
                    iconAnchor: [10, 10]
                })
            }).bindPopup(`<b>${document.getElementById('businessName').value || 'Business Location'}</b>`);
            businessMarker.addTo(map);
            markers.push(businessMarker);

            // Add grid point markers
            gridPoints.forEach(point => {
                const marker = L.circleMarker([point.lat, point.lon], {
                    radius: 8,
                    fillColor: '#00d4ff',
                    color: '#fff',
                    weight: 2,
                    opacity: 1,
                    fillOpacity: 0.7
                }).bindPopup(`Point ${point.id}<br>Distance: ${point.distanceKm} km`);
                marker.addTo(map);
                markers.push(marker);
            });

            // Draw grid boundary
            const bounds = [
                [Math.min(...gridPoints.map(p => p.lat)), Math.min(...gridPoints.map(p => p.lon))],
                [Math.max(...gridPoints.map(p => p.lat)), Math.max(...gridPoints.map(p => p.lon))]
            ];

            const rectangle = L.rectangle(bounds, {
                color: '#7b2cbf',
                weight: 2,
                fill: false
            });
            rectangle.addTo(map);
            markers.push(rectangle);

            // Fit map to bounds
            map.fitBounds(bounds, { padding: [50, 50] });

            showStatus(`Generated ${gridPoints.length} grid points`, 'success');

            // Initialize empty grid visual
            updateGridVisual();
        }

        // Search keyword at location using SerpAPI
        async function searchKeywordAtLocation(apiKey, keyword, lat, lon, businessName, country) {
            // SerpAPI endpoint (using CORS proxy for browser)
            // Note: In production, you should use your own backend proxy
            const params = new URLSearchParams({
                api_key: apiKey,
                engine: 'google',
                q: keyword,
                ll: `@${lat},${lon},14z`,
                hl: 'en',
                gl: country,
                google_domain: country === 'uk' ? 'google.co.uk' : 'google.com',
                device: 'mobile',
                num: 20
            });

            try {
                const response = await fetch(`https://serpapi.com/search.json?${params}`);

                if (!response.ok) {
                    throw new Error(`API Error: ${response.status}`);
                }

                const results = await response.json();

                const resultData = {
                    keyword: keyword,
                    locationLat: lat,
                    locationLon: lon,
                    businessName: businessName,
                    timestamp: new Date().toISOString(),
                    localPackPosition: null,
                    organicPosition: null,
                    localPackPresent: false,
                    competitorsInLocalPack: [],
                    foundInOrganic: false
                };

                // Check Local Pack
                if (results.local_results) {
                    const localPack = results.local_results;
                    resultData.localPackPresent = localPack.length > 0;

                    for (let idx = 0; idx < Math.min(localPack.length, 10); idx++) {
                        const business = localPack[idx];
                        const businessTitle = (business.title || '').toLowerCase();

                        if (businessTitle.includes(businessName.toLowerCase())) {
                            resultData.localPackPosition = idx + 1;
                            break;
                        }

                        resultData.competitorsInLocalPack.push({
                            name: business.title || '',
                            position: idx + 1,
                            rating: business.rating || 0,
                            reviews: business.reviews || 0
                        });
                    }
                }

                // Check Organic Results
                if (results.organic_results) {
                    const organicResults = results.organic_results;

                    for (let idx = 0; idx < Math.min(organicResults.length, 50); idx++) {
                        const result = organicResults[idx];
                        const title = (result.title || '').toLowerCase();
                        const link = (result.link || '').toLowerCase();

                        if (title.includes(businessName.toLowerCase()) ||
                            link.includes(businessName.toLowerCase().replace(/\s+/g, ''))) {
                            resultData.organicPosition = idx + 1;
                            resultData.foundInOrganic = true;
                            break;
                        }
                    }
                }

                return resultData;

            } catch (error) {
                console.error('Search error:', error);
                return null;
            }
        }

        // Start tracking
        async function startTracking() {
            const apiKey = document.getElementById('apiKey').value;
            const businessName = document.getElementById('businessName').value;
            const keywordsText = document.getElementById('keywords').value;
            const country = document.getElementById('country').value;

            if (!apiKey) {
                showStatus('Please enter your SerpAPI key', 'error');
                return;
            }

            if (!businessName) {
                showStatus('Please enter your business name', 'error');
                return;
            }

            if (!keywordsText.trim()) {
                showStatus('Please enter at least one keyword', 'error');
                return;
            }

            if (gridPoints.length === 0) {
                showStatus('Please generate grid points first', 'error');
                return;
            }

            const keywords = keywordsText.split('\n').map(k => k.trim()).filter(k => k);

            if (keywords.length === 0) {
                showStatus('Please enter at least one keyword', 'error');
                return;
            }

            // Show progress section
            document.getElementById('progressSection').style.display = 'block';
            document.getElementById('metricsSection').style.display = 'grid';
            document.getElementById('startTrackingBtn').style.display = 'none';
            document.getElementById('stopTrackingBtn').style.display = 'block';

            isTracking = true;
            trackingResults = [];

            const totalTasks = keywords.length * gridPoints.length;
            let completedTasks = 0;

            showStatus(`Starting tracking: ${keywords.length} keywords × ${gridPoints.length} points = ${totalTasks} searches`, 'info');

            for (const keyword of keywords) {
                if (!isTracking) break;

                for (const point of gridPoints) {
                    if (!isTracking) break;

                    updateProgress(completedTasks, totalTasks, `Searching: "${keyword}" at point ${point.id}`);

                    const result = await searchKeywordAtLocation(
                        apiKey, keyword, point.lat, point.lon, businessName, country
                    );

                    if (result) {
                        result.locationId = point.id;
                        result.gridX = point.gridX;
                        result.gridY = point.gridY;
                        trackingResults.push(result);
                    }

                    completedTasks++;
                    updateProgress(completedTasks, totalTasks, `Completed: "${keyword}" at point ${point.id}`);

                    // Update visualizations in real-time
                    updateMetrics();
                    updateMapMarkers();
                    updateGridVisual();
                    updateKeywordTable(keywords);
                    updateRawDataTable();

                    // Rate limiting - 1 second delay
                    if (isTracking && completedTasks < totalTasks) {
                        await sleep(1000);
                    }
                }
            }

            // Tracking complete
            isTracking = false;
            document.getElementById('startTrackingBtn').style.display = 'block';
            document.getElementById('stopTrackingBtn').style.display = 'none';

            if (completedTasks === totalTasks) {
                showStatus('Tracking complete!', 'success');
            } else {
                showStatus('Tracking stopped', 'warning');
            }

            // Final update
            updateKeywordChart(keywords);
        }

        // Stop tracking
        function stopTracking() {
            isTracking = false;
            showStatus('Stopping tracking...', 'warning');
        }

        // Update progress
        function updateProgress(completed, total, message) {
            const percent = (completed / total) * 100;
            document.getElementById('progressFill').style.width = `${percent}%`;
            document.getElementById('progressText').textContent = `${completed}/${total} - ${message}`;
        }

        // Calculate and update metrics
        function updateMetrics() {
            if (trackingResults.length === 0) return;

            const total = trackingResults.length;
            const localPackCount = trackingResults.filter(r => r.localPackPosition !== null).length;
            const top3Count = trackingResults.filter(r => r.localPackPosition !== null && r.localPackPosition <= 3).length;
            const organicCount = trackingResults.filter(r => r.organicPosition !== null).length;

            const localPositions = trackingResults
                .filter(r => r.localPackPosition !== null)
                .map(r => r.localPackPosition);
            const avgPosition = localPositions.length > 0
                ? (localPositions.reduce((a, b) => a + b, 0) / localPositions.length).toFixed(1)
                : '-';

            document.getElementById('metricLocalPack').textContent = `${((localPackCount / total) * 100).toFixed(1)}%`;
            document.getElementById('metricTop3').textContent = `${((top3Count / total) * 100).toFixed(1)}%`;
            document.getElementById('metricOrganic').textContent = `${((organicCount / total) * 100).toFixed(1)}%`;
            document.getElementById('metricAvgPos').textContent = avgPosition;
        }

        // Update map markers with results
        function updateMapMarkers() {
            // Clear existing markers (except first one which is business)
            while (markers.length > 1) {
                const marker = markers.pop();
                map.removeLayer(marker);
            }

            // Group results by location
            const locationResults = {};
            trackingResults.forEach(r => {
                if (!locationResults[r.locationId]) {
                    locationResults[r.locationId] = [];
                }
                locationResults[r.locationId].push(r);
            });

            // Add markers for each grid point
            gridPoints.forEach(point => {
                const results = locationResults[point.id] || [];
                const localPositions = results.filter(r => r.localPackPosition !== null).map(r => r.localPackPosition);
                const avgPosition = localPositions.length > 0
                    ? localPositions.reduce((a, b) => a + b, 0) / localPositions.length
                    : null;

                let color = '#424242'; // No data
                if (avgPosition !== null) {
                    if (avgPosition <= 3) color = '#4CAF50';
                    else if (avgPosition <= 10) color = '#FFC107';
                    else if (avgPosition <= 20) color = '#FF9800';
                    else color = '#F44336';
                }

                const marker = L.circleMarker([point.lat, point.lon], {
                    radius: 12,
                    fillColor: color,
                    color: '#fff',
                    weight: 2,
                    opacity: 1,
                    fillOpacity: 0.8
                }).bindPopup(`
                    <b>Point ${point.id}</b><br>
                    Avg Position: ${avgPosition ? avgPosition.toFixed(1) : 'N/A'}<br>
                    Keywords Found: ${localPositions.length}/${results.length}
                `);
                marker.addTo(map);
                markers.push(marker);
            });
        }

        // Update grid visual
        function updateGridVisual() {
            const gridSize = parseInt(document.getElementById('gridSize').value);
            const gridVisual = document.getElementById('gridVisual');
            gridVisual.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;

            // Group results by location
            const locationResults = {};
            trackingResults.forEach(r => {
                if (!locationResults[r.locationId]) {
                    locationResults[r.locationId] = [];
                }
                locationResults[r.locationId].push(r);
            });

            let html = '';

            // Generate grid cells (reversed Y for visual display)
            for (let i = gridSize; i >= 1; i--) {
                for (let j = 1; j <= gridSize; j++) {
                    const pointId = `${i}-${j}`;
                    const results = locationResults[pointId] || [];
                    const localPositions = results.filter(r => r.localPackPosition !== null).map(r => r.localPackPosition);

                    let className = 'no-data';
                    let label = '-';

                    if (localPositions.length > 0) {
                        const avgPosition = localPositions.reduce((a, b) => a + b, 0) / localPositions.length;
                        label = avgPosition.toFixed(1);

                        if (avgPosition <= 3) className = 'rank-1-3';
                        else if (avgPosition <= 10) className = 'rank-4-10';
                        else if (avgPosition <= 20) className = 'rank-11-20';
                        else className = 'rank-not-found';
                    } else if (results.length > 0) {
                        className = 'rank-not-found';
                        label = 'NF';
                    }

                    html += `<div class="grid-cell ${className}" title="Point ${pointId}">${label}</div>`;
                }
            }

            gridVisual.innerHTML = html;
        }

        // Update keyword table
        function updateKeywordTable(keywords) {
            const tbody = document.querySelector('#keywordTable tbody');

            let html = '';
            keywords.forEach(keyword => {
                const keywordResults = trackingResults.filter(r => r.keyword === keyword);
                const total = keywordResults.length || 1;
                const localPackCount = keywordResults.filter(r => r.localPackPosition !== null).length;
                const top3Count = keywordResults.filter(r => r.localPackPosition !== null && r.localPackPosition <= 3).length;
                const organicCount = keywordResults.filter(r => r.organicPosition !== null).length;

                const localPositions = keywordResults.filter(r => r.localPackPosition !== null).map(r => r.localPackPosition);
                const avgPosition = localPositions.length > 0
                    ? (localPositions.reduce((a, b) => a + b, 0) / localPositions.length).toFixed(1)
                    : '-';

                html += `
                    <tr>
                        <td>${keyword}</td>
                        <td>${((localPackCount / total) * 100).toFixed(1)}%</td>
                        <td>${((top3Count / total) * 100).toFixed(1)}%</td>
                        <td>${((organicCount / total) * 100).toFixed(1)}%</td>
                        <td>${avgPosition}</td>
                    </tr>
                `;
            });

            tbody.innerHTML = html;
        }

        // Update keyword chart
        function updateKeywordChart(keywords) {
            const ctx = document.getElementById('keywordChart').getContext('2d');

            if (keywordChart) {
                keywordChart.destroy();
            }

            const data = keywords.map(keyword => {
                const keywordResults = trackingResults.filter(r => r.keyword === keyword);
                const total = keywordResults.length || 1;
                return {
                    keyword: keyword,
                    localPack: keywordResults.filter(r => r.localPackPosition !== null).length,
                    top3: keywordResults.filter(r => r.localPackPosition !== null && r.localPackPosition <= 3).length,
                    organic: keywordResults.filter(r => r.organicPosition !== null).length
                };
            });

            keywordChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: data.map(d => d.keyword),
                    datasets: [
                        {
                            label: 'Local Pack',
                            data: data.map(d => d.localPack),
                            backgroundColor: 'rgba(0, 212, 255, 0.7)',
                            borderColor: '#00d4ff',
                            borderWidth: 1
                        },
                        {
                            label: 'Top 3',
                            data: data.map(d => d.top3),
                            backgroundColor: 'rgba(76, 175, 80, 0.7)',
                            borderColor: '#4CAF50',
                            borderWidth: 1
                        },
                        {
                            label: 'Organic',
                            data: data.map(d => d.organic),
                            backgroundColor: 'rgba(123, 44, 191, 0.7)',
                            borderColor: '#7b2cbf',
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { color: '#fff' }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { color: '#888' },
                            grid: { color: 'rgba(255,255,255,0.1)' }
                        },
                        y: {
                            ticks: { color: '#888' },
                            grid: { color: 'rgba(255,255,255,0.1)' }
                        }
                    }
                }
            });
        }

        // Update raw data table
        function updateRawDataTable() {
            const tbody = document.querySelector('#rawDataTable tbody');

            let html = '';
            trackingResults.forEach(result => {
                const competitors = result.competitorsInLocalPack.slice(0, 3).map(c => c.name).join(', ') || '-';
                html += `
                    <tr>
                        <td>${result.locationId}</td>
                        <td>${result.keyword}</td>
                        <td>${result.localPackPosition || 'Not found'}</td>
                        <td>${result.organicPosition || 'Not found'}</td>
                        <td>${competitors}</td>
                    </tr>
                `;
            });

            tbody.innerHTML = html;
        }

        // Export to CSV
        function exportCSV() {
            if (trackingResults.length === 0) {
                showStatus('No data to export', 'error');
                return;
            }

            const headers = ['Point ID', 'Keyword', 'Latitude', 'Longitude', 'Local Pack Position', 'Organic Position', 'Timestamp'];
            const rows = trackingResults.map(r => [
                r.locationId,
                r.keyword,
                r.locationLat,
                r.locationLon,
                r.localPackPosition || '',
                r.organicPosition || '',
                r.timestamp
            ]);

            const csv = [headers.join(','), ...rows.map(r => r.join(','))].join('\n');
            downloadFile(csv, `local_seo_tracking_${Date.now()}.csv`, 'text/csv');
        }

        // Export to JSON
        function exportJSON() {
            if (trackingResults.length === 0) {
                showStatus('No data to export', 'error');
                return;
            }

            const json = JSON.stringify(trackingResults, null, 2);
            downloadFile(json, `local_seo_tracking_${Date.now()}.json`, 'application/json');
        }

        // Download file helper
        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Show status message
        function showStatus(message, type) {
            const statusEl = document.getElementById('statusMessage');
            statusEl.className = `status-message status-${type}`;
            statusEl.textContent = message;
            statusEl.style.display = 'block';
        }

        // Tab switching
        function showTab(tabName) {
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

            document.querySelector(`[onclick="showTab('${tabName}')"]`).classList.add('active');
            document.getElementById(`tab-${tabName}`).classList.add('active');

            // Refresh map when switching to map tab
            if (tabName === 'map' && map) {
                setTimeout(() => map.invalidateSize(), 100);
            }
        }

        // Sleep helper
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            initMap();

            // Load saved API key from localStorage
            const savedApiKey = localStorage.getItem('serpapi_key');
            if (savedApiKey) {
                document.getElementById('apiKey').value = savedApiKey;
            }

            // Save API key on change
            document.getElementById('apiKey').addEventListener('change', function() {
                localStorage.setItem('serpapi_key', this.value);
            });
        });
    </script>
</body>
</html>
